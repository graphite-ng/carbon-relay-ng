package main

import (
	"fmt"
	"regexp"
	"regexp/syntax"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/grafana/carbon-relay-ng/cfg"
)

type group struct {
	Num  int
	Name string
	Patt string
}

// groups returns the matching groups from a parsed regex
func groups(re *syntax.Regexp) []group {
	var g []group
	for _, s := range re.Sub {
		if s.Op == syntax.OpCapture {
			g = append(g, group{
				Num:  s.Cap,
				Name: s.Name,
				Patt: s.Sub0[0].String(),
			})
		}
	}
	return g
}

// reverseRegex returns the "reverse regex" of an aggregation:
// the format of an aggregator turned into a regex by replacing the groups with the capture groups from the aggregations regex.
//
// to know whether a metrickey may be the output of an aggregation, we must:
// * fill in the sub-patterns from the groups into the format, aka the reverseRegex
// * verify whether the metric key matches formatRegex
// note: as we don't know what the input metric was, we cannot match anything against the original regex
// for example:
// consider this aggregation:
// regex: '^stats.([^\.]+)\.(bar)\.[^\.]+*\.(?P<path>[a-zA-Z]+).count'
// format: 'aggstats.$1.$2.$path.count'
// let's say we encounter a metric with the name 'aggstats.foo.foo.somepath.count'
// we want to know if it could possibly have been generated through this aggregation
// we rephrase the question by expanding the format:
// * replace literal '.' with '\.'
// * fill in the groups by their patterns
// result: aggstats\.[^\.]+\.bar\.[a-zA-Z]+\.count
// does the metric match this regex? If so, than it *may* have been generated by this aggregation
func reverseRegex(agg cfg.Aggregation) (*regexp.Regexp, error) {
	re, err := syntax.Parse(agg.Regex, syntax.Perl)
	if err != nil {
		return nil, err
	}
	groups := groups(re)
	escFormat := strings.Replace(agg.Format, ".", `\.`, -1)

	formatRegex, err := expand(nil, escFormat, groups)
	if err != nil {
		return nil, err
	}

	return regexp.Compile(string(formatRegex))
}

// expand parses all the leading variables
// based on stdlib regexp.Regexp.Expand
func expand(dst []byte, template string, groups []group) ([]byte, error) {
	for len(template) > 0 {
		i := strings.Index(template, "$")
		if i < 0 {
			break
		}
		dst = append(dst, template[:i]...)
		template = template[i:]
		if len(template) > 1 && template[1] == '$' {
			// Treat $$ as $.
			dst = append(dst, '$')
			template = template[2:]
			continue
		}
		name, num, rest, ok := extract(template)
		if !ok {
			fmt.Println("Malformed variable syntax. treat $ as raw text")
			dst = append(dst, '$')
			template = template[1:]
			continue
		}
		template = rest
		var found bool
		if num >= 0 {
			for _, g := range groups {
				if g.Num == num {
					dst = append(dst, []byte(g.Patt)...)
					found = true
					break
				}
			}
		} else {
			for _, g := range groups {
				if g.Name == name {
					dst = append(dst, []byte(g.Patt)...)
					found = true
					break
				}
			}
		}
		if !found {
			return dst, fmt.Errorf("could not find variable %s/%d", name, num)
		}
	}
	dst = append(dst, template...)
	return dst, nil
}

// extract returns the name from a leading "$name" or "${name}" in str.
// If it is a number, extract returns num set to that number; otherwise num = -1.
// taken from on stdlib regexp.extract()
func extract(str string) (name string, num int, rest string, ok bool) {
	if len(str) < 2 || str[0] != '$' {
		return
	}
	brace := false
	if str[1] == '{' {
		brace = true
		str = str[2:]
	} else {
		str = str[1:]
	}
	i := 0
	for i < len(str) {
		rune, size := utf8.DecodeRuneInString(str[i:])
		if !unicode.IsLetter(rune) && !unicode.IsDigit(rune) && rune != '_' {
			break
		}
		i += size
	}
	if i == 0 {
		// empty name is not okay
		return
	}
	name = str[:i]
	if brace {
		if i >= len(str) || str[i] != '}' {
			// missing closing brace
			return
		}
		i++
	}

	// Parse number.
	num = 0
	for i := 0; i < len(name); i++ {
		if name[i] < '0' || '9' < name[i] || num >= 1e8 {
			num = -1
			break
		}
		num = num*10 + int(name[i]) - '0'
	}
	// Disallow leading zeros.
	if name[0] == '0' && len(name) > 1 {
		num = -1
	}

	rest = str[i:]
	ok = true
	return

}
